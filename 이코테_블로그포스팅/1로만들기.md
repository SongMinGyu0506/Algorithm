## 문제
* 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지 이다.

* X가 5로 나누어 떨어지면, 5로 나눈다.  
X가 3으로 나누어 떨어지면, 3으로 나눈다.  
X가 2로 나누어 떨어지면, 2로 나눈다.  
1을 뺀다.  
* 정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

* __입력__  
첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

* __출력__  
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

|입력 예시|출력 예시
|--|--|
26|3
---
## 해설
* 다이나믹 프로그래밍을 활용하는 문제  
* 작은 값부터 활용하는 바텀업 방식 사용  
* 메모이제이션을 활용하는 배열을 이용하여 사용한다.  
* 예로, 원하는 값이 2인 경우, 1로 한번만 빼면 되므로 1
* 원하는 값이 3인 경우, 2의 값이 저장되어있으므로 1을 빼는 경우는 2에 저장되어 있는 값 + 1을 빼는 행동으로 2, 하지만 3을 나누는 행동을 할경우 1회만 하면 1이 된다. 이런 경우를 고려하여 비교하면서 메모배열에 저장한다.

---
## 코드
```python
d = [0] * 30000

x = int(input())

for i in range(2,x+1):
    d[i] = d[i-1] +1 # 1을 빼는 경우 1 이전 계산 결과에서 또 1을 빼야하므로 이전값에서 1 추가
    if i % 2 == 0:
        d[i] = min(d[i],d[i//2]+1) #1 빼는 계산 횟수 vs /2 계산결과 + 이전값 1 추가
    if i % 3 == 0:
        d[i] = min(d[i],d[i//3]+1) #1 빼는 계산 횟수 vs /3 계산결과 + 이전값 1 추가
    if i % 5 == 0:
        d[i] = min(d[i],d[i//5]+1) #1 빼는 계산 횟수 vs /5 계산결과 + 이전값 1 추가
print(d[x])
```

